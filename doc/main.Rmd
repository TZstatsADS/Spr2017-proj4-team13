---
title: "Project 4 -  Main Script"
author: "Boxuan Zhao, Zixuan Guan, Zheren Tang, Yingxin Zhang, Jihan Wei"
date: "3/22/2017"
output: 
  pdf_document: 
    latex_engine: xelatex
---

This file is currently a template for implementing one of the suggested papers, Han, Zha, & Giles (2005). Due to the nature of the method, we only implement the method on a subset of the data, "AKumar.txt". In your project, you need to work on the whole dataset. You should follow the same structure as in this tutorial, but update it according to the papers you are assigned.

## Step 0: Load the packages, specify directories

```{r}
##########################################################################################################
# Here replace it with your own path or manually set it in RStudio to the lib folder                     #
setwd("D:/Columbia University/Spring2017-Applied Data Science/Project_4_Bz2290/Spr2017-proj4-team13/lib")#
##########################################################################################################

#Relevant packages
list.of.packages = c("expm","pacman","text2vec")

new.packages = list.of.packages[!(list.of.packages %in% install.packages()[,"Package"])]

if(length(new.packages))
{
  install.packages(new.packages)
}

library("expm")
library("pacman")
library("text2vec")

#if (!require("pacman")) install.packages("pacman")
#pacman::p_load(text2vec, dplyr, qlcMatrix, kernlab, knitr)



#Specify relevant functions needed
source("../lib/Create_Matrix.R")
```

## Step 1: Load and process the data

For each record in the dataset, there are some information we want to extract and store them in a regular form: canonical author id, coauthors, paper title, publication venue title. You may need to find regular matched in the input string vectors by using regex in R. Here is a tutorial for regular expression in R, which might help you <https://rstudio-pubs-static.s3.amazonaws.com/74603_76cd14d5983f47408fdf0b323550b846.html>

We will extract all relevant information from data in this chunck
```{r}
#AKumar <- data.frame(scan("data/nameset/AKumar.txt",
#                          what = list(Coauthor = "", Paper = "", Journal = ""),
#                          sep=">", quiet=TRUE),stringsAsFactors=FALSE)
# This need to be modified for different name set

# extract canonical author id befor "_"
#AKumar$AuthorID <- sub("_.*","",AKumar$Coauthor)
# extract paper number under same author between "_" and first whitespace
#AKumar$PaperNO <- sub(".*_(\\w*)\\s.*", "\\1", AKumar$Coauthor)
# delete "<" in AKumar$Coauthor, you may need to further process the coauthor
# term depending on the method you are using
#AKumar$Coauthor <- gsub("<","",sub("^.*?\\s","", AKumar$Coauthor))
# delete "<" in AKumar$Paper
#AKumar$Paper <- gsub("<","",AKumar$Paper)
# add PaperID for furthur use, you may want to combine all the nameset files and 
# then assign the unique ID for all the citations
#AKumar$PaperID <- rownames(AKumar)

AGupta = read.csv("../data/namecsv/AGupta.csv",header = TRUE, stringsAsFactors = FALSE)
AKumar = read.csv("../data/namecsv/AKumar.csv",header = TRUE, stringsAsFactors = FALSE)
CChen = read.csv("../data/namecsv/CChen.csv",header = TRUE, stringsAsFactors = FALSE)
DJohnson = read.csv("../data/namecsv/DJohnson.csv",header = TRUE, stringsAsFactors = FALSE)
JLee =  read.csv("../data/namecsv/JLee.csv",header = TRUE, stringsAsFactors = FALSE)
JMartin = read.csv("../data/namecsv/JMartin.csv",header = TRUE, stringsAsFactors = FALSE)
JRobinson  = read.csv("../data/namecsv/JRobinson.csv",header = TRUE, stringsAsFactors = FALSE)
JSmith = read.csv("../data/namecsv/JSmith.csv",header = TRUE, stringsAsFactors = FALSE)
KTanaka = read.csv("../data/namecsv/KTanaka.csv",header = TRUE, stringsAsFactors = FALSE)
MBrown = read.csv("../data/namecsv/MBrown.csv",header = TRUE, stringsAsFactors = FALSE)
MJones = read.csv("../data/namecsv/MJones.csv",header = TRUE, stringsAsFactors = FALSE)
MMiller = read.csv("../data/namecsv/MMiller.csv",header = TRUE, stringsAsFactors = FALSE)
SLee = read.csv("../data/namecsv/SLee.csv",header = TRUE, stringsAsFactors = FALSE)
YChen = read.csv("../data/namecsv/YChen.csv",header = TRUE, stringsAsFactors = FALSE)

#Input all the information
#Original = read.csv("../data/namecsv/All_Stacked.csv")
#Original$Coauthor = as.character(Original$Coauthor)
#Original$Paper = as.character(Original$Paper)
#Original$Journal = as.character(Original$Journal)
#The dimension
#dim(Original)
#Column name
#colnames(Original)
```

## Step 2: Feature design

Following the section 3.1 in the paper, we want to use paper titles to design features for citations. As the notation used in the paper, we want to find a $m$-dimensional citation vector $\alpha_i$ for each citation $i$, $i=1,...,n$. In this dataset, $n=$ `r nrow(AKumar)`. We study "TF-IDF" (term frequency-inverse document frequency) as suggested in the paper.

TF-IDF is a numerical statistics that is intended to reflect how important a word is to a document in a collection or corpus. It is often used as a weighting factor in information retrieval, text mining, and user modeling. The TF-IDF value increases proportionally to the number of times a word appears in the document, but is offset by the frequency of the word in the corpus, which helps to adjust for the fact that some words appear more frequently in general.

$$
\begin{aligned}
\mbox{TF}(t) &=\frac{\mbox{Number of times term $t$ appears in a document}}{\mbox{Total number of terms in the document}}\\
\mbox{IDF}(t) &=\log{\frac{\mbox{Total number of documents}}{\mbox{Number of documents with term $t$ in it}}}\\
\mbox{TF-IDF}(t) &=\mbox{TF}(t)\times\mbox{IDF}(t)
\end{aligned}
$$

```{r}
source("../lib/paper3/TFIDF_FeatureDesign.R")
#For paper 3
AGupta.Coauthor = Create_Coauthor(AGupta)
AGupta.Paper = Create_Title(AGupta)
AGupta.Journal = Create_Journal(AGupta)
AKumar.Coauthor = Create_Coauthor(AKumar)
AKumar.Paper = Create_Title(AKumar)
AKumar.Journal = Create_Journal(AKumar)
CChen.Coauthor = Create_Coauthor(CChen)
CChen.Paper = Create_Title(CChen)
CChen.Journal = Create_Journal(CChen)
DJohnson.Coauthor = Create_Coauthor(DJohnson)
DJohnson.Paper = Create_Title(DJohnson)
DJohnson.Journal = Create_Journal(DJohnson)
JLee.Coauthor = Create_Coauthor(JLee)
JLee.Paper = Create_Title(JLee)
JLee.Journal = Create_Journal(JLee)
JMartin.Coauthor = Create_Coauthor(JMartin)
JMartin.Paper = Create_Title(JMartin)
JMartin.Journal = Create_Journal(JMartin)
JRobinson.Coauthor = Create_Coauthor(JRobinson)
JRobinson.Paper = Create_Title(JRobinson)
JRobinson.Journal = Create_Journal(JRobinson)
JSmith.Coauthor = Create_Coauthor(JSmith)
JSmith.Paper = Create_Title(JSmith)
JSmith.Journal = Create_Journal(JSmith)
KTanaka.Coauthor = Create_Coauthor(KTanaka)
KTanaka.Paper = Create_Title(KTanaka)
KTanaka.Journal = Create_Journal(KTanaka)
MBrown.Coauthor = Create_Coauthor(MBrown)
MBrown.Paper = Create_Title(MBrown)
MBrown.Journal = Create_Journal(MBrown)
MJones.Coauthor = Create_Coauthor(MJones)
MJones.Paper = Create_Title(MJones)
MJones.Journal = Create_Journal(MJones)
MMiller.Coauthor = Create_Coauthor(MMiller)
MMiller.Paper = Create_Title(MMiller)
MMiller.Journal = Create_Journal(MMiller)
SLee.Coauthor = Create_Coauthor(SLee)
SLee.Paper = Create_Title(SLee)
SLee.Journal = Create_Journal(SLee)
YChen.Coauthor = Create_Coauthor(YChen)
YChen.Paper = Create_Title(YChen)
YChen.Journal = Create_Journal(YChen)

#P3.Coauthor = Create_Coauthor(Original)
#P3.Paper = Create_Title(Original)
#P3.Journal = Create_Journal(Original)
#### Load and process data for paper 6
```

To compute TF-IDF, we first need to construct a document-term matrix (DTM). In other words, the first step is to vectorize text by creating a map from words to a vector space. There are some good packages you could use for text mining (probably you have tried during first project, you don't need to follow my code if you are familiar with other package), e.g. *text2vec, tm, tidytext*. Here, we are going to use *text2vec* package. A good tutorial can be found here, <https://cran.r-project.org/web/packages/text2vec/vignettes/text-vectorization.html>.

## Step 3: Clustering

First of all, we perofrom the spectral cluster with QR decomposition on the data sets
```{r}
source("../lib/paper3/Spectral ClusterQR.R")
#For AGupta
AGupta_sclust.coauthor <- Spectral.Cluster(my.dat=AGupta.Coauthor, n.cluster=length(unique(AGupta$AuthorID)))

AGupta_sclust.paper <- Spectral.Cluster(my.dat=AGupta.Paper, n.cluster=length(unique(AGupta$AuthorID)))

AGupta_sclust.journal <- Spectral.Cluster(my.dat=AGupta.Journal, n.cluster=length(unique(AGupta$AuthorID)))
  
#For AKumar
AKumar_sclust.coauthor <- Spectral.Cluster(AKumar.Coauthor, n.cluster=length(unique(AKumar$AuthorID)))

AKumar_sclust.paper <- Spectral.Cluster(AKumar.Paper, n.cluster=length(unique(AKumar$AuthorID)))

AKumar_sclust.journal <- Spectral.Cluster(AKumar.Journal, n.cluster=length(unique(AKumar$AuthorID)))

#For CChen
CChen_sclust.coauthor <- Spectral.Cluster(CChen.Coauthor, n.cluster=length(unique(CChen$AuthorID)))

CChen_sclust.paper <- Spectral.Cluster(CChen.Paper, n.cluster=length(unique(CChen$AuthorID)))

CChen_sclust.journal <- Spectral.Cluster(CChen.Journal, n.cluster=length(unique(CChen$AuthorID)))

#For DJohnson
DJohnson_sclust.coauthor <- Spectral.Cluster(DJohnson.Coauthor, n.cluster=length(unique(DJohnson$AuthorID)))

DJohnson_sclust.paper <- Spectral.Cluster(DJohnson.Paper, n.cluster=length(unique(DJohnson$AuthorID)))

DJohnson_sclust.journal <- Spectral.Cluster(DJohnson.Journal, n.cluster=length(unique(DJohnson$AuthorID)))

#For JLee
JLee_sclust.coauthor <- Spectral.Cluster(JLee.Coauthor, n.cluster=length(unique(JLee$AuthorID)))

JLee_sclust.paper <- Spectral.Cluster(JLee.Paper, n.cluster=length(unique(JLee$AuthorID)))

JLee_sclust.journal <- Spectral.Cluster(JLee.Journal, n.cluster=length(unique(JLee$AuthorID)))

#For JMartin
JMartin_sclust.coauthor <- Spectral.Cluster(JMartin.Coauthor, n.cluster=length(unique(JMartin$AuthorID)))

JMartin_sclust.paper <- Spectral.Cluster(JMartin.Paper, n.cluster=length(unique(JMartin$AuthorID)))

JMartin_sclust.journal <- Spectral.Cluster(JMartin.Journal, n.cluster=length(unique(JMartin$AuthorID)))

#For JRobinson
JRobinson_sclust.coauthor <- Spectral.Cluster(JRobinson.Coauthor, n.cluster=length(unique(JRobinson$AuthorID)))

JRobinson_sclust.paper <- Spectral.Cluster(JRobinson.Paper, n.cluster=length(unique(JRobinson$AuthorID)))

JRobinson_sclust.journal <- Spectral.Cluster(JRobinson.Journal, n.cluster=length(unique(JRobinson$AuthorID)))

#For JSmith
JSmith_sclust.coauthor <- Spectral.Cluster(JSmith.Coauthor, n.cluster=length(unique(JSmith$AuthorID)))

JSmith_sclust.paper <- Spectral.Cluster(JSmith.Paper, n.cluster=length(unique(JSmith$AuthorID)))

JSmith_sclust.journal <- Spectral.Cluster(JSmith.Journal, n.cluster=length(unique(JSmith$AuthorID)))

#For KTanaka
KTanaka_sclust.coauthor <- Spectral.Cluster(KTanaka.Coauthor, n.cluster=length(unique(KTanaka$AuthorID)))

KTanaka_sclust.paper <- Spectral.Cluster(KTanaka.Paper, n.cluster=length(unique(KTanaka$AuthorID)))

KTanaka_sclust.journal <- Spectral.Cluster(KTanaka.Journal, n.cluster=length(unique(KTanaka$AuthorID)))

#For MBrown
MBrown_sclust.coauthor <- Spectral.Cluster(MBrown.Coauthor, n.cluster=length(unique(MBrown$AuthorID)))

MBrown_sclust.paper <- Spectral.Cluster(MBrown.Paper, n.cluster=length(unique(MBrown$AuthorID)))

MBrown_sclust.journal <- Spectral.Cluster(MBrown.Journal, n.cluster=length(unique(MBrown$AuthorID)))

#For MJones
MJones_sclust.coauthor <- Spectral.Cluster(MJones.Coauthor, n.cluster=length(unique(MJones$AuthorID)))

MJones_sclust.paper <- Spectral.Cluster(MJones.Paper, n.cluster=length(unique(MJones$AuthorID)))

MJones_sclust.journal <- Spectral.Cluster(MJones.Journal, n.cluster=length(unique(MJones$AuthorID)))

#For MMiller
MMiller_sclust.coauthor <- Spectral.Cluster(MMiller.Coauthor, n.cluster=length(unique(MMiller$AuthorID)))

MMiller_sclust.paper <- Spectral.Cluster(MMiller.Paper, n.cluster=length(unique(MMiller$AuthorID)))

MMiller_sclust.journal <- Spectral.Cluster(MMiller.Journal, n.cluster=length(unique(MMiller$AuthorID)))

#For SLee
SLee_sclust.coauthor <- Spectral.Cluster(SLee.Coauthor, n.cluster=length(unique(SLee$AuthorID)))

SLee_sclust.paper <- Spectral.Cluster(SLee.Paper, n.cluster=length(unique(SLee$AuthorID)))

SLee_sclust.journal <- Spectral.Cluster(SLee.Journal, n.cluster=length(unique(SLee$AuthorID)))

#For YChen
YChen_sclust.coauthor <- Spectral.Cluster(YChen.Coauthor, n.cluster=length(unique(YChen$AuthorID)))

YChen_sclust.paper <- Spectral.Cluster(YChen.Paper, n.cluster=length(unique(YChen$AuthorID)))

YChen_sclust.journal <- Spectral.Cluster(YChen.Journal, n.cluster=length(unique(YChen$AuthorID)))







#specc(as.matrix(dtm_train_tfidf), 
                       #centers=length(unique(AKumar$AuthorID)))
#end.time.specc.journal <- Sys.time()
#time_sclust.journal <- end.time.specc.journal - start.time.specc.journal




#table(result_sclust)
```

Second of all, we imlememnt the algorithm we use from paper 6 to analysis our data set. 
```{r}
#start.time <- Sys.time()
#docsdissim <- cosSparse(t(dtm_train_tfidf))
#rownames(docsdissim) <- c(1:nrow(dtm_train_tfidf))
#colnames(docsdissim) <- c(1:nrow(dtm_train_tfidf))
#compute pairwise cosine similarities using cosSparse function in package qlcMatrix
#h <- hclust(as.dist(docsdissim), method = "ward.D")
#result_hclust <- cutree(h,length(unique(AKumar$AuthorID)))
#end.time <- Sys.time()
#time_hclust <- end.time - start.time
#table(result_hclust)
```

## Step 4: Evaluation

To evaluate the performance of the method, it is required to calculate the degree of agreement between a set of system-output partitions and a set of true partitions. In general, the agreement between two partitioins is measured for a pair of entities within partitions. The basic unit for which pair-wise agreement is assessed is a pair of entities (authors in our case) which belongs to one of the four cells in the following table (Kang et at.(2009)):

\includegraphics[width=500pt]{matching_matrix.png}

Let $M$ be the set of machine-generated clusters, and $G$ the set of gold standard clusters. Then. in the table, for example, $a$ is the number of pairs of entities that are assigned to the same cluster in each of $M$ and $G$. Hence, $a$ and $d$ are interpreted as agreements, and $b$ and $c$ disagreements. When the table is considered as a confusion matrix for a two-class prediction problem, the standard "Precision", "Recall","F1", and "Accuracy" are defined as follows.

$$
\begin{aligned}
\mbox{Precision} &=\frac{a}{a+b}\\
\mbox{Recall}&=\frac{a}{a+c}\\
\mbox{F1} &=\frac{2\times\mbox{Precision}\times\mbox{Recall}}{\mbox{Precision}+\mbox{Recall}}\\
\mbox{Accuracy}&=\frac{a+d}{a+b+c+d}
\end{aligned}
$$
We first evalue our algorithm using the gold standard

For paper 3
```{r}
source('evaluation_measures.R')
#matching_matrix_hclust <- matching_matrix(AKumar$AuthorID,result_hclust)
#performance_hclust <- performance_statistics(matching_matrix_hclust)
#matching_matrix_sclust <- matching_matrix(AKumar$AuthorID,result_sclust)
#performance_sclust <- performance_statistics(matching_matrix_sclust)
#compare_df <- data.frame(method=c("sClust","hClust"),
 #                        precision=c(performance_sclust$precision, performance_hclust$precision),
  #                       recall=c(performance_sclust$recall, performance_hclust$recall),
   #                      f1=c(performance_sclust$f1, performance_hclust$f1),
    #                     accuracy=c(performance_sclust$accuracy, performance_hclust$accuracy),
     #                    time=c(time_sclust,time_hclust))
#kable(compare_df,caption="Comparision of performance for two clustering methods",digits = 2)


spec_eva <- function(author,result){
  matching <- matching_matrix(author$AuthorID,result)
  perform <- performance_statistics(matching)
  return(as.data.frame(perform))
}


AGupta.m1 = spec_eva(AGupta,AGupta_sclust.coauthor)
AGupta.m2 = spec_eva(AGupta,AGupta_sclust.paper)
AGupta.m3 = spec_eva(AGupta,AGupta_sclust.journal)

AKumar.m1 = spec_eva(AKumar,AKumar_sclust.coauthor)
AKumar.m2 = spec_eva(AKumar,AKumar_sclust.paper)
AKumar.m3 = spec_eva(AKumar,AKumar_sclust.journal)

CChen.m1 = spec_eva(CChen,CChen_sclust.coauthor)
CChen.m2 = spec_eva(CChen,CChen_sclust.paper)
CChen.m3 = spec_eva(CChen,CChen_sclust.journal)

DJohnson.m1 = spec_eva(DJohnson,DJohnson_sclust.coauthor)
DJohnson.m2 = spec_eva(DJohnson,DJohnson_sclust.paper)
DJohnson.m3 = spec_eva(DJohnson,DJohnson_sclust.journal)

JLee.m1 = spec_eva(JLee,JLee_sclust.coauthor)
JLee.m2 = spec_eva(JLee,JLee_sclust.paper)
JLee.m3 = spec_eva(JLee,JLee_sclust.journal)

JMartin.m1 = spec_eva(JMartin,JMartin_sclust.coauthor)
JMartin.m2 = spec_eva(JMartin,JMartin_sclust.paper)
JMartin.m3 = spec_eva(JMartin,JMartin_sclust.journal)

JRobinson.m1 = spec_eva(JRobinson,JRobinson_sclust.coauthor)
JRobinson.m2 = spec_eva(JRobinson,JRobinson_sclust.paper)
JRobinson.m3 = spec_eva(JRobinson,JRobinson_sclust.journal)

JSmith.m1 = spec_eva(JSmith,JSmith_sclust.coauthor)
JSmith.m2 = spec_eva(JSmith,JSmith_sclust.paper)
JSmith.m3 = spec_eva(JSmith,JSmith_sclust.journal)

KTanaka.m1 = spec_eva(KTanaka,KTanaka_sclust.coauthor)
KTanaka.m2 = spec_eva(KTanaka,KTanaka_sclust.paper)
KTanaka.m3 = spec_eva(KTanaka,KTanaka_sclust.journal)

MBrown.m1 = spec_eva(MBrown,MBrown_sclust.coauthor)
MBrown.m2 = spec_eva(MBrown,MBrown_sclust.paper)
MBrown.m3 = spec_eva(MBrown,MBrown_sclust.journal)

MJones.m1 = spec_eva(MJones,MJones_sclust.coauthor)
MJones.m2 = spec_eva(MJones,MJones_sclust.paper)
MJones.m3 = spec_eva(MJones,MJones_sclust.journal)

MMiller.m1 = spec_eva(MMiller,MMiller_sclust.coauthor)
MMiller.m2 = spec_eva(MMiller,MMiller_sclust.paper)
MMiller.m3 = spec_eva(MMiller,MMiller_sclust.journal)

SLee.m1 = spec_eva(SLee,SLee_sclust.coauthor)
SLee.m2 = spec_eva(SLee,SLee_sclust.paper)
SLee.m3 = spec_eva(SLee,SLee_sclust.journal)

YChen.m1 = spec_eva(YChen,YChen_sclust.coauthor)
YChen.m2 = spec_eva(YChen,YChen_sclust.paper)
YChen.m3 = spec_eva(YChen,YChen_sclust.journal)


eva_df <- rbind(AGupta.m1,AGupta.m2,AGupta.m3,AKumar.m1,AKumar.m2,AKumar.m3,
                CChen.m1,CChen.m2,CChen.m3,DJohnson.m1,DJohnson.m2,DJohnson.m3,
                JLee.m1,JLee.m2,JLee.m3,JMartin.m1,JMartin.m2,JMartin.m3,
                JRobinson.m1,JRobinson.m2,JRobinson.m3,JSmith.m1,JSmith.m2,
                JSmith.m3,KTanaka.m1,KTanaka.m2,KTanaka.m3,MBrown.m1,MBrown.m2,
                MBrown.m3,MJones.m1,MJones.m2,MJones.m3,MMiller.m1,MMiller.m2,
                MMiller.m3,SLee.m1,SLee.m2,SLee.m3,YChen.m1,YChen.m2,YChen.m3)

rownames(eva_df) <- c("AGupta_coauthor","AGupta_paper","AGupta_journal",
                      "AKumar_coauthor","AKumar_paper","AKumar_journal",
                      "CChen_coauthor","CChen_paper","CChen_journal",
                      "DJohnson_coauthor","DJohnson_paper","DJohnson_journal",
                      "JLee_coauthor","JLee_paper","JLee_journal",
                      "JMartin_coauthor","JMartin_paper","JMartin_journal",
                      "JRobinson_coauthor","JRobinson_paper","JRobinson_journal",
                      "JSmith_coauthor","JSmith_paper","JSmith_journal",
                      "KTanaka_coauthor","KTanaka_paper","KTanaka_journal",
                      "MBrown_coauthor","MBrown_paper","MBrown_journal",
                      "MJones_coauthor","MJones_paper","MJones_journal",
                      "MMiller_coauthor","MMiller_paper","MMiller_journal",
                      "SLee_coauthor","SLee_paper","SLee_journal",
                      "YChen_coauthor","YChen_paper","YChen_journal")

#kable(eva_df,caption="Comparision of performance for two clustering methods",digits = 2)

write.csv(eva_df, file = "../output/paper3/eva.csv")

```

For paper 6
```{r}

```

Then we use our own ways to evalute 

For paper 3
```{r}
source("../lib/paper3/Misclassification.R")

AGupta.m1 = Misclassification(AGupta,AGupta_sclust.coauthor)
AGupta.m2 = Misclassification(AGupta,AGupta_sclust.paper)
AGupta.m3 = Misclassification(AGupta,AGupta_sclust.journal)

AKumar.m1 = Misclassification(AKumar,AKumar_sclust.coauthor)
AKumar.m2 = Misclassification(AKumar,AKumar_sclust.paper)
AKumar.m3 = Misclassification(AKumar,AKumar_sclust.journal)

CChen.m1 = Misclassification(CChen,CChen_sclust.coauthor)
CChen.m2 = Misclassification(CChen,CChen_sclust.paper)
CChen.m3 = Misclassification(CChen,CChen_sclust.journal)

DJohnson.m1 = Misclassification(DJohnson,DJohnson_sclust.coauthor)
DJohnson.m2 = Misclassification(DJohnson,DJohnson_sclust.paper)
DJohnson.m3 = Misclassification(DJohnson,DJohnson_sclust.journal)

JLee.m1 = Misclassification(JLee,JLee_sclust.coauthor)
JLee.m2 = Misclassification(JLee,JLee_sclust.paper)
JLee.m3 = Misclassification(JLee,JLee_sclust.journal)

JMartin.m1 = Misclassification(JMartin,JMartin_sclust.coauthor)
JMartin.m2 = Misclassification(JMartin,JMartin_sclust.paper)
JMartin.m3 = Misclassification(JMartin,JMartin_sclust.journal)

JRobinson.m1 = Misclassification(JRobinson,JRobinson_sclust.coauthor)
JRobinson.m2 = Misclassification(JRobinson,JRobinson_sclust.paper)
JRobinson.m3 = Misclassification(JRobinson,JRobinson_sclust.journal)

JSmith.m1 = Misclassification(JSmith,JSmith_sclust.coauthor)
JSmith.m2 = Misclassification(JSmith,JSmith_sclust.paper)
JSmith.m3 = Misclassification(JSmith,JSmith_sclust.journal)

KTanaka.m1 = Misclassification(KTanaka,KTanaka_sclust.coauthor)
KTanaka.m2 = Misclassification(KTanaka,KTanaka_sclust.paper)
KTanaka.m3 = Misclassification(KTanaka,KTanaka_sclust.journal)

MBrown.m1 = Misclassification(MBrown,MBrown_sclust.coauthor)
MBrown.m2 = Misclassification(MBrown,MBrown_sclust.paper)
MBrown.m3 = Misclassification(MBrown,MBrown_sclust.journal)

MJones.m1 = Misclassification(MJones,MJones_sclust.coauthor)
MJones.m2 = Misclassification(MJones,MJones_sclust.paper)
MJones.m3 = Misclassification(MJones,MJones_sclust.journal)

MMiller.m1 = Misclassification(MMiller,MMiller_sclust.coauthor)
MMiller.m2 = Misclassification(MMiller,MMiller_sclust.paper)
MMiller.m3 = Misclassification(MMiller,MMiller_sclust.journal)

SLee.m1 = Misclassification(SLee,SLee_sclust.coauthor)
SLee.m2 = Misclassification(SLee,SLee_sclust.paper)
SLee.m3 = Misclassification(SLee,SLee_sclust.journal)

YChen.m1 = Misclassification(YChen,YChen_sclust.coauthor)
YChen.m2 = Misclassification(YChen,YChen_sclust.paper)
YChen.m3 = Misclassification(YChen,YChen_sclust.journal)

error.rate = data.frame(filename = c("AGupta","AKumar","CChen","DJohnson","JLee","JMartin","JRobinson","JSmith","KTanaka","MBrown","MJones","MMiller","SLee","YChen"), Coauthor = c(AGupta.m1[[2]],AKumar.m1[[2]],CChen.m1[[2]],DJohnson.m1[[2]],JLee.m1[[2]],JMartin.m1[[2]],JRobinson.m1[[2]],JSmith.m1[[2]],KTanaka.m1[[2]],MBrown.m1[[2]],MJones.m1[[2]],MMiller.m1[[2]],SLee.m1[[2]],YChen.m1[[2]]), Journal= c(AGupta.m2[[2]],AKumar.m2[[2]],CChen.m2[[2]],DJohnson.m2[[2]],JLee.m2[[2]],JMartin.m2[[2]],JRobinson.m2[[2]],JSmith.m2[[2]],KTanaka.m2[[2]],MBrown.m2[[2]],MJones.m2[[2]],MMiller.m2[[2]],SLee.m2[[2]],YChen.m2[[2]]), Paper=c(AGupta.m3[[2]],AKumar.m3[[2]],CChen.m3[[2]],DJohnson.m3[[2]],JLee.m3[[2]],JMartin.m3[[2]],JRobinson.m3[[2]],JSmith.m3[[2]],KTanaka.m3[[2]],MBrown.m3[[2]],MJones.m3[[2]],MMiller.m3[[2]],SLee.m3[[2]],YChen.m3[[2]]))
write.csv(error.rate, file = "../output/paper3/misclassification.csv")
```

For paper 6
```{r}

```

